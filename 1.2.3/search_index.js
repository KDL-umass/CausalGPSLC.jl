var documenterSearchIndex = {"docs":
[{"location":"contributing/#Contributing-to-GPSLC.jl","page":"Contributing","title":"Contributing to GPSLC.jl","text":"","category":"section"},{"location":"contributing/#Development","page":"Contributing","title":"Development","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"For basic editing of small portions of the GPSLC.jl source code,  you can use Revise.jl to ensure the package is precompiled and up-to-date.","category":"page"},{"location":"contributing/#Forks","page":"Contributing","title":"Forks","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If you intend to make a contribution to GPSLC.jl,  please make a fork of this repository and work on your additions there.","category":"page"},{"location":"contributing/#Pull-Requests","page":"Contributing","title":"Pull Requests","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"When the changes on your fork are ready for review,  please create a pull request on Github to the dev branch of GPSLC.jl. Please also mention any relevant issues the PR is intending to address in the  description of the PR.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If your changes aren't ready for submission but you would like feedback,  please create a pull request on Github as above, but mark it as a Draft. This will let reviewers know that the PR is in-progress and looking for feedback. Feel free to add any extra comments or extend the description to indicate what you would like reviwed.","category":"page"},{"location":"contributing/#Setup","page":"Contributing","title":"Setup","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"It's recommended to create a ~/.julia/config/startup.jl file with the following contents:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using Pkg\nif isfile(\"Project.toml\") && isfile(\"Manifest.toml\")\n    Pkg.activate(\".\")\nend\ntry\n    using Revise\ncatch \nend","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"This makes it so $ julia bash commands will run in the GPSLC environment.","category":"page"},{"location":"contributing/#Revise","page":"Contributing","title":"Revise","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"In the Julia REPL execute","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using Pkg, Revise\nPkg.activate(\".\")\nusing GPSLC","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"And then you're good to go and add things as needed and rerun them. Revise should keep things up to date in the REPL as changes are made.","category":"page"},{"location":"contributing/#Testing","page":"Contributing","title":"Testing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"All changes should be accompanied by corresponding tests in the test suite found in test/runtests.jl.  We recommend using test-driven-development (TDD) and writing tests for the components prior to the components themselves, so you know they work as expected once they've been written.  There are many good resources out there for TDD.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If you're using Visual Studio Code with the Julia extension, the contents of runtests.jl, the GPSLCTests module can be executed using Shift+Enter or similar,  and it will include a call to Revise.jl so that the GPSLC.jl package is up to date.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"You can also run the tests straight from the REPL by running","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"include(\"test/runtests.jl\")","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"or to run the full test suite including package installation verification","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"import Pkg; Pkg.test(\"GPSLC\")","category":"page"},{"location":"contributing/#Coverage","page":"Contributing","title":"Coverage","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"To check code coverage, run ","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"$ julia --code-coverage test/runtests.jl","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Which will work assuming you have followed the instructions  in Setup","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"CurrentModule = GPSLC","category":"page"},{"location":"#Gaussian-Processes-with-Structured-Latent-Confounders","page":"Documentation","title":"Gaussian Processes with Structured Latent Confounders","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"GPSLC.jl is a Julia package for semi-parametric causal effect estimation with structured latent confounding. It provides interfaces for performing causal inference over the latent variables and Gaussian process parameters to produce accurate causal effect estimates.","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"The original GP-SLC paper can be found here: http://proceedings.mlr.press/v119/witty20a/witty20a.pdf.","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"Pages=[\"index.md\"]\nDepth = 3","category":"page"},{"location":"#Inference","page":"Documentation","title":"Inference","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"gpslc","category":"page"},{"location":"#GPSLC.gpslc","page":"Documentation","title":"GPSLC.gpslc","text":"gpslc(filename * \".csv\")\ngpslc(filename * \".csv\"; hyperparams=hyperparams, priorparams=priorparams))\n\ngpslc(DataFrame(X1=...,X2=...,T=...,Y=...,obj=...))\ngpslc(DataFrame(X1=...,X2=...,T=...,Y=...,obj=...); hyperparams=hyperparams, priorparams=priorparams)\n\nRun posterior inference on the input data.\n\nDatatypes of DataFrame or CSV must follow these standards:\n\nT (Boolean/Float64)\nY (Float64)\nX1...XN (Float64...Float64)\nobj (Any)\n\nOptional parameters\n\nhyperparams::HyperParameters=getHyperParameters(): Hyper parameters primarily define the high level amount of inference to perform.\npriorparams::PriorParameters=getPriorParameters(): Prior parameters define the high level priors to draw from when constructing kernel functions and latent confounder structure.\n\nReturns a GPSLCObject which stores the  hyperparameters, prior parameters, data, and posterior samples.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Documentation","title":"Documentation","text":"The primary struct that we provide interfaces for is the GPSLCObject, which most of the high-level functions like the  treatment effect functions take as input  in addition to their other arguments.","category":"page"},{"location":"#Treatment-Effects","page":"Documentation","title":"Treatment Effects","text":"","category":"section"},{"location":"#Individual-Treatment-Effect-(ITE)","page":"Documentation","title":"Individual Treatment Effect (ITE)","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"A contribution of the original GP-SLC paper is to produce accurate individual treatment effect estimates, conditioned on the observed data and using the inferred values of the latent confounders as determined by the provided structure.","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"sampleITE","category":"page"},{"location":"#GPSLC.sampleITE","page":"Documentation","title":"GPSLC.sampleITE","text":"sampleITE(g, doT)\nsampleITE(g, doT; samplesPerPosterior=10)\n\nEstimate Individual Treatment Effect with GPSLC model\n\nParams:\n\ng::GPSLCObject: Contains data and hyperparameters\ndoT: The requested intervention (e.g. set all treatments to 1.0)\nsamplesPerPosterior: How many ITE samples to draw per posterior sample in g.\n\nReturns:\n\nITEsamples: n x m matrix where n is the number of individuals, and m is the number of samples.\n\n\n\n\n\n","category":"function"},{"location":"#Sample-Average-Treatment-Effect-(SATE)","page":"Documentation","title":"Sample Average Treatment Effect (SATE)","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"Another popular and useful treatment effect estimate is SATE,  which averages individual treatment effects over the individuals in the sample.","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"sampleSATE","category":"page"},{"location":"#GPSLC.sampleSATE","page":"Documentation","title":"GPSLC.sampleSATE","text":"sampleSATE(g, doT)\nsampleSATE(g, doT; samplesPerPosterior=10)\n\nEstimate Sample Average Treatment Effect with GPSLC model\n\nUsing sampleITE, samples can be drawn for the sample average treatment effect\n\nParams:\n\ng::GPSLCObject: Contains data and hyperparameters\ndoT: The requested intervention (e.g. set all treatments to 1.0)\nsamplesPerPosterior: How many samples to draw per posterior sample in g.\n\nReturns:\n\nSATEsamples: n x m matrix where n is the number of individuals, and m is the number of samples.\n\n\n\n\n\n","category":"function"},{"location":"#Counterfactual-Effects","page":"Documentation","title":"Counterfactual Effects","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"It can be helpful to calculate treatment effect estimates for the whole domain of treatment values in the data, or some subset, as in the example below. For this we can use predictCounterfactualEffects, which also tracks the values of the doT intervention values for comparison.","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"predictCounterfactualEffects","category":"page"},{"location":"#GPSLC.predictCounterfactualEffects","page":"Documentation","title":"GPSLC.predictCounterfactualEffects","text":"predictCounterfactualOutcomes(g, nSamplesPerMixture)\npredictCounterfactualOutcomes(g, nSamplesPerMixture; fidelity=100)\npredictCounterfactualOutcomes(g, nSamplesPerMixture; fidelity=100, minDoT=0, maxDoT=5)\n\nParams\n\ng::GPSLCObject: The GPSLCObject that inference has already been computed for.\nnSamplesPerMixture::Int64: The number of outcome samples to \n\ndraw from each set of inferred posterior parameters.\n\nfidelity::Int64: How many intervention values to use to cover the domain of treatment values. Higher means more samples.\nminDoT::Float64=min(g.T...): The lowest interventional treatment to use.Defaults to the data g.T's lowest treatment value.\nmaxDoT::Float64=max(g.T...): The highest interventional treatment to use. Defaults to the data g.T's highest treatment value.\n\njulia> ite, doT = predictCounterfactualEffects(g, 30; fidelity=100)\n\nReturns \n\nite::Matrix{Float64}: An array of size [d, n, numPosteriorSamples * nSamplesPerMixture] where d is the number of interventional values defined by fidelity and the range of treatments in g.T - doTrange::Vector{Float64}: The list values of doT used, in order that matches the rows of ite.\n\n\n\n\n\n","category":"function"},{"location":"#Summarizing","page":"Documentation","title":"Summarizing","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"It can be helpful to summarize the inferred individual treatment effects and sample average treatment effects into mean and credible intervals. A use case for this is demonstrated in the examples section.","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"summarizeEstimates","category":"page"},{"location":"#GPSLC.summarizeEstimates","page":"Documentation","title":"GPSLC.summarizeEstimates","text":"summarizeEstimates(samples)\nsummarizeEstimates(samples; savetofile=\"ite_samples.csv\")\n\nSummarize Predicted Estimates (Counterfactual Outcomes or Individual Treatment Effects)\n\nCreate dataframe of mean, lower and upper quantiles of the samples from sampleITE or predictCounterfactualEffects.\n\nParams:\n\nsamples: The n x m array of samples from sampleSATE or sampleITE\nsavetofile::String: Optionally save the resultant DataFrame as CSV to the filename passed\ncredible_interval::Float64: A real in [0,1] where 0.90 is the default for a 90% credible interval\n\nReturns:\n\ndf: Dataframe of Individual, Mean, LowerBound, and UpperBound values for the credible intervals around the sample.\n\n\n\n\n\n","category":"function"},{"location":"#Examples","page":"Documentation","title":"Examples","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"The examples below illustrate use cases for","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"setting hyperparameters, \nperforming inference,\nsaving inference results,\npredicting counterfactual effects,\ncalculating sample average treatment effect (SATE),\ncomputing credible intervals for SATE,\nand plotting those intervals relative to the original data","category":"page"},{"location":"#New-England-Energy-Consumption","page":"Documentation","title":"New England Energy Consumption","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"This example creates an example plot of the NEEC treatment vs outcome data. Plots the original and the intervened data together. The example below is similar to Figure 3 in the original GP-SLC paper.","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"import Random # hide\nRandom.seed!(1234) # hide\nusing GPSLC # hide\nusing Plots # hide\nusing Statistics # hide\n\n# set hyperparameters\nhyperparams = getHyperParameters()\nhyperparams.nOuter = 25\nhyperparams.nU = 2\nhyperparams.nMHInner = 3\nhyperparams.nESInner = 5\n\n# run inference\ndataFile = \"../example_data/NEEC_sampled.csv\"\ng = gpslc(dataFile; hyperparams=hyperparams)\nsaveGPSLCObject(g, \"exampleGPSLCObject\")\n\n# collect counterfactual outcomes\nmaIdx = vec(g.obj .== \"MA\")\nnSamples = 100\nite, doT = predictCounterfactualEffects(g, nSamples)\nmaITE = ite[:, maIdx, :]\n\n# get credible interval on counterfactual outcomes\nsate = mean(maITE, dims=2)[:, 1, :]\ninterval = summarizeEstimates(sate)\n\nmeanOutcome = mean(g.Y[maIdx])\nlowerSATE = interval[!, \"LowerBound\"]\nmeanSATE = interval[!, \"Mean\"]\nupperSATE = interval[!, \"UpperBound\"]\n\n# plot outcomes and credible interval\ntreatmentScale = 100\noutcomeScale = 10\n\n# observed data\nplot(legend=:outertopright, size=(750, 400), margin=0.5Plots.cm, dpi=600)\nobsT = g.T[maIdx] .* treatmentScale\nobsY = g.Y[maIdx] .* outcomeScale\nscatter!(obsT, obsY, label=\"MA obs\", markershape=:circle)\n\n# counterfactual\nTcf = doT .* treatmentScale\nYcf = (meanOutcome .+ meanSATE) .* outcomeScale\nupper = (upperSATE .- meanSATE) .* outcomeScale\nlower = (meanSATE .- lowerSATE) .* outcomeScale\n\nplot!(Tcf, Ycf, label=\"MA cf\", color=:green,\n    ribbon=(lower, upper))\n\nxlabel!(\"Temperature Â°F\")\nylabel!(\"Energy Consumption (GWh)\")\ntitle!(\"Energy Consumption for Massachusetts\")","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"Above we can see the Gaussian Process using individual treatment effect estimates to predict the energy consumption (outcome) from the temperature (treatment) for Massachusetts. The shaded region is a 90% credible interval from the samples taken by predictCounterfactualEffects and processed by summarizeEstimates which calculates the credible intervals by computing the 5th and 95th percentiles of the samples.","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"The data used in this example can be found here.","category":"page"},{"location":"#Types","page":"Documentation","title":"Types","text":"","category":"section"},{"location":"#External-Types","page":"Documentation","title":"External Types","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"External types are those relevant for using GPSLC.jl in a high-level way,  where inference and prediction are automatically performed.","category":"page"},{"location":"#HyperParameters","page":"Documentation","title":"HyperParameters","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"HyperParameters","category":"page"},{"location":"#GPSLC.HyperParameters","page":"Documentation","title":"GPSLC.HyperParameters","text":"HyperParameters\n\nDefine the high-level attributes of the inference procedure. More information on each of the attributes can be found in getHyperParameters.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Documentation","title":"Documentation","text":"The default values for HyperParameters are provided by","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"getHyperParameters","category":"page"},{"location":"#GPSLC.getHyperParameters","page":"Documentation","title":"GPSLC.getHyperParameters","text":"getHyperParameters()\n\nReturns default values for hyperparameters\n\nnU = 1: Number of latent confounding variables assumed to be influencing all the instances that belong to one object. Inference will be performed over these values.\nnOuter = 20: Number of posterior samples to draw.\nnMHInner = 5: Number of internal Metropolis-Hastings updates to make per posterior sample.\nnESInner = 5: Number of elliptical-slice sampling updates to make per posterior for latent confounders and binary treatment.\nnBurnIn = 5: Number of posterior samples to discard when making predictions and estimates.\nstepSize = 1: How frequently to use posterior samples (1 being every one after burnIn, higher being every stepSizeth).\npredictionCovarianceNoise=1e-10: Predicting with Gaussian processes requires use of covariance matrices that are Symmetric Positive Definite, and this covariance noise on the diagonal ensures these operations can be performed in a stable and consistent way.\n\n\n\n\n\n","category":"function"},{"location":"#PriorParameters","page":"Documentation","title":"PriorParameters","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"PriorParameters","category":"page"},{"location":"#GPSLC.PriorParameters","page":"Documentation","title":"GPSLC.PriorParameters","text":"PriorParameters\n\nA dictionary of shapes and scales for various Inverse Gamma distributions used as priors for kernel parameters and other parameters. More information on each of the attributes can be found in getPriorParameters.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Documentation","title":"Documentation","text":"The default values for PriorParameters are provided by","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"getPriorParameters","category":"page"},{"location":"#GPSLC.getPriorParameters","page":"Documentation","title":"GPSLC.getPriorParameters","text":"getPriorParameters()\n\nThese are standard values for scale and shape of Inverse Gamma priors over kernel parameters, confounder structure covariance noise, and confounder Gaussian prior covariance. \n\nuNoiseShape::Float64=4.0: shape of the InvGamma prior over the noise of U\nuNoiseScale::Float64=4.0: scale of the InvGamma prior over the noise of U\nxNoiseShape::Float64=4.0: shape of the InvGamma prior over the noise of X\nxNoiseScale::Float64=4.0: scale of the InvGamma prior over the noise of X\ntNoiseShape::Float64=4.0: shape of the InvGamma prior over the noise of T\ntNoiseScale::Float64=4.0: scale of the InvGamma prior over the noise of T\nyNoiseShape::Float64=4.0: shape of the InvGamma prior over the noise of Y\nyNoiseScale::Float64=4.0: scale of the InvGamma prior over the noise of Y\nxScaleShape::Float64=4.0: shape of the InvGamma prior over kernel scale of X\nxScaleScale::Float64=4.0: scale of the InvGamma prior over kernel scale of X\ntScaleShape::Float64=4.0: shape of the InvGamma prior over kernel scale of T\ntScaleScale::Float64=4.0: scale of the InvGamma prior over kernel scale of T\nyScaleShape::Float64=4.0: shape of the InvGamma prior over kernel scale of Y\nyScaleScale::Float64=4.0: scale of the InvGamma prior over kernel scale of Y\nuxLSShape::Float64=4.0: shape of the InvGamma prior over kernel lengthscale of U and X\nuxLSScale::Float64=4.0: scale of the InvGamma prior over kernel lengthscale of U and X\nutLSShape::Float64=4.0: shape of the InvGamma prior over kernel lengthscale of U and T\nutLSScale::Float64=4.0: scale of the InvGamma prior over kernel lengthscale of U and T\nxtLSShape::Float64=4.0: shape of the InvGamma prior over kernel lengthscale of X and T\nxtLSScale::Float64=4.0: scale of the InvGamma prior over kernel lengthscale of X and T\nuyLSShape::Float64=4.0: shape of the InvGamma prior over kernel lengthscale of U and Y\nuyLSScale::Float64=4.0: scale of the InvGamma prior over kernel lengthscale of U and Y\nxyLSShape::Float64=4.0: shape of the InvGamma prior over kernel lengthscale of X and Y\nxyLSScale::Float64=4.0: scale of the InvGamma prior over kernel lengthscale of X and Y\ntyLSShape::Float64=4.0: shape of the InvGamma prior over kernel lengthscale of T and Y\ntyLSScale::Float64=4.0: scale of the InvGamma prior over kernel lengthscale of T and Y\nsigmaUNoise::Float64=1.0e-13: noise added to matrix to make covariance stable and invertible\nsigmaUCov::Float64=1.0: assumed covariance over structured confounders\ndrift::Float64=0.5: as in the paper, Metropolis Hastings Gaussian Drift\n\n\n\n\n\n","category":"function"},{"location":"#GPSLCObject","page":"Documentation","title":"GPSLCObject","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"The GPSLCObject is the high-level Julia struct that most of the externally facing interfaces rely on to perform their operations. Since it contains inference samples, the hyperparameters, and the observed data, it is at the center of all post-inference interfaces that manipulate the posterior samples according to the observed data. ","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"This also means that the GPSLCObject contains the result of a large portion  of compute time, as well as contains all the relevant data for a given workflow.  For this reason, all the fields and functions that utilize it are externally available, and described below, to provide users with a simple way to extend the functionality  of GPSLC.jl and estimate other quantities of interest.","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"GPSLCObject","category":"page"},{"location":"#GPSLC.GPSLCObject","page":"Documentation","title":"GPSLC.GPSLCObject","text":"GPSLCObject\n\nThis is the struct in GPSLC.jl that contains the data, hyperparamters, prior parameters, and posterior samples. It provides the primary interfaces to abstract the internals of GPSLC away from the higher-order functions like sampleITE, sampleSATE, and predictCounterfactualEffects.\n\nReturned by gpslc\n\n\n\n\n\n","category":"type"},{"location":"#Retrieving-meta-values-from-a-GPSLCObject","page":"Documentation","title":"Retrieving meta-values from a GPSLCObject","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"getN","category":"page"},{"location":"#GPSLC.getN","page":"Documentation","title":"GPSLC.getN","text":"getN(g)\n\nNumber of individuals in dataset.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Documentation","title":"Documentation","text":"getNX","category":"page"},{"location":"#GPSLC.getNX","page":"Documentation","title":"GPSLC.getNX","text":"getNX(g)\n\nNumber of covariates (and observed confounders) in dataset.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Documentation","title":"Documentation","text":"getNU","category":"page"},{"location":"#GPSLC.getNU","page":"Documentation","title":"GPSLC.getNU","text":"getNU(g)\n\nNumber of latent confounders to perform inference over (hyperparameter).\n\n\n\n\n\n","category":"function"},{"location":"","page":"Documentation","title":"Documentation","text":"getNumPosteriorSamples","category":"page"},{"location":"#GPSLC.getNumPosteriorSamples","page":"Documentation","title":"GPSLC.getNumPosteriorSamples","text":"getNumPosteriorSamples(g)\n\nNumber of posterior samples that will be used based on hyperparameters.\n\n(total posterior samples - burn in) / step size = nBurnIn:stepSize:nOuter\n\n\n\n\n\n","category":"function"},{"location":"#Saving-and-loading-GPSLCObjects","page":"Documentation","title":"Saving and loading GPSLCObjects","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"GPSLCObjects contain all the posterior samples, which can be intensive to calculate and can be reused for various estimations, we provide a pair of interfaces to save and load the GPSLCObjects from the filesystem.","category":"page"},{"location":"","page":"Documentation","title":"Documentation","text":"saveGPSLCObject","category":"page"},{"location":"#GPSLC.saveGPSLCObject","page":"Documentation","title":"GPSLC.saveGPSLCObject","text":"saveGPSLCObject(g, filename)\nsaveGPSLCObject(g, \"path/to/filename\")\nsaveGPSLCObject(g, \"path/to/filename.gpslc\")\n\nThis function will save the GPSLCObject g to the file <filename>.gpslc. This GPSLCObject, including the posterior samples contained within it can be retrieved with the loadGPSLCObject function.\n\nNote: The extension .gpslc is optional and will be added if it is not included.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Documentation","title":"Documentation","text":"loadGPSLCObject","category":"page"},{"location":"#GPSLC.loadGPSLCObject","page":"Documentation","title":"GPSLC.loadGPSLCObject","text":"loadGPSLCObject(filename)\nloadGPSLCObject(\"path/to/filename\")\nloadGPSLCObject(\"path/to/filename.gpslc\")\n\nThis function will load and return the GPSLCObject contained in <filename>.gpslc. \n\nNote: the extension .gpslc is optional and will be added if it is not included.\n\n\n\n\n\n","category":"function"},{"location":"#Internal-Types","page":"Documentation","title":"Internal Types","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"These types are are used in internal inference procedures, so if users need to fine tune or modify the inference procedure,  or access the model directly, these will be relevant.","category":"page"},{"location":"#Confounders","page":"Documentation","title":"Confounders","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"Confounders","category":"page"},{"location":"#GPSLC.Confounders","page":"Documentation","title":"GPSLC.Confounders","text":"Confounders (U)\n\nLatent confounders that GPSLC performs inference over.\n\nEither 1D or 2D matrices of Float64 values.\n\n\n\n\n\n","category":"type"},{"location":"#Covariates","page":"Documentation","title":"Covariates","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"Covariates","category":"page"},{"location":"#GPSLC.Covariates","page":"Documentation","title":"GPSLC.Covariates","text":"Covariates (X) Observed confounders and covariates.\n\nMatrix{Float64} is the only valid structure for covariates\n\n\n\n\n\n","category":"type"},{"location":"#Treatment","page":"Documentation","title":"Treatment","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"Treatment","category":"page"},{"location":"#GPSLC.Treatment","page":"Documentation","title":"GPSLC.Treatment","text":"Treatment (T)\n\nIs made up of BinaryTreatment which is an alias for Vector{Bool} and ContinuousTreatment which is an alias for Vector{Float64}. These types support other vector types to afford compatibility with internal libraries.\n\n\n\n\n\n","category":"type"},{"location":"#Outcome","page":"Documentation","title":"Outcome","text":"","category":"section"},{"location":"","page":"Documentation","title":"Documentation","text":"Outcome","category":"page"},{"location":"#GPSLC.Outcome","page":"Documentation","title":"GPSLC.Outcome","text":"Outcome (Y)\n\nThe outcome for the series of Gaussian Process predictions is a Vector{Float64}. Currently only continuous values are supported as outcomes for input data.\n\n\n\n\n\n","category":"type"}]
}
